#include<linux/init.h>
#include<linux/module.h>
#include<linux/cdev.h>
#include<linux/fs.h>
#include<linux/uaccess.h>
#include<linux/vmalloc.h>

#deline MAX_DEVICES 10
#deline MAJOR_NUM  101
#deline MINOR_NUM  0
#deline BUFFER_SIZE 1048576

struct_device_date
{
   struct cdev   chardev
   unsigned char   *buffer;
   int   npos;
}*mydate[MAX_DEVICE];
static ssize_t device_read(struct file*filp,
                           char__user*buff,size_t len,loff_t*offset)
{
   int nlen=len;
   struct_device_data*pdb=filp->private_date;
   
   if(nlen>pdb->npos-*offset)
        nlen=pdb->npos-*offset;
   if(copy_to_user(buff,(pdb->buffer)+*offset,nlen))
   return-EFAULT;
   *offset+=nlen;
   return nlen;
}

static ssize_t device_write(struct file*filp,
                           const char__user*buff,size_t len,loff_t*offset)
{
   int nlen=len;
   struct_device_data*pdb=filp>private_data;
   
   if(nlen>BUFFER_SIZE-pdb->npos)
         nlen=BUFFER_SIZE-pdb->npos;
    if (nlen==0)
         return-ENOMEM;
   if (copy_from_user(&pdb->buffer[pdb->npos],buff,nlen))
         return-EFAULT;
   pdb->npos+=nlen;
   return len;
}
static ssize_t device_open(strut inode*inode,strut file*filp)
{
   int nminor=iminor(inode);
  
   if(!mydata[nminor]->buffer)
         mydata[nminor]->buffer=(unsigned char*)vmalloc(BUFFER_SIZE);
   if(!mydata[nminor]->buffer)
         return-ENOMEM;
   filp->private_data=mydata[nminor];
   if((filp->flags&O_ACCMODE)==O_WRONLY)
        mydata[nminor]->npos=0;
   return 0;
}

        
        
        
        
        
        
                           
